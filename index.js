const fs = require('fs');
function 读取文件(文件名) {
    try {
        const 数据 = fs.readFileSync(文件名, 'utf8');
        return 数据;
    } catch (错误) {
        console.error('读取文件时出错:', 错误);
        return null;
    }
}
function 读取JSON文件(文件名) {
    return JSON.parse(读取文件(文件名))
}
function 写入文件(文件名, 内容) {
    fs.writeFile(文件名, JSON.stringify(内容), function (错误) {
        if (错误) {
            console.error('保存数据到文件时出错:', 错误);
        } else {
            console.log('数据成功保存到文件:', 文件名);
        }
    });
}
function 从数组中随机选择(数组) {
    let 随机索引 = Math.floor(Math.random() * 数组.length);
    return 数组[随机索引];
}
function 生成参数(构造数组) {
    let 参数 = [[], []];


    for (let i = 0; i < 构造数组.length - 1; i++) {
        let 当前层神经元数量 = 构造数组[i];
        let 下一层神经元数量 = 构造数组[i + 1];

        let 当前层权重 = [];
        let 当前层偏置 = [];

        for (let j = 0; j < 下一层神经元数量; j++) {
            let 当前神经元权重 = [];
            let 当前神经元偏置 = Math.random();
            for (let k = 0; k < 当前层神经元数量; k++) {
                当前神经元权重.push(Math.random());
            }

            当前层权重.push(当前神经元权重);
            当前层偏置.push(当前神经元偏置);
        }

        参数[0][i] = 当前层权重;
        参数[1][i] = 当前层偏置;
    }
    打印(`生成参数成功`);
    return 参数;
}
function 前向传播(输入, 参数) {
    let 神经网络层数 = 参数[0].length;

    let 正向传播结果 = 输入;
    for (let i = 0; i < 神经网络层数; i++) {
        let 当前层权重 = 参数[0][i];
        let 当前层偏置 = 参数[1][i];

        let 下一层神经元数量 = 当前层权重.length;
        let 当前层神经元数量 = 当前层权重[0].length;

        let 当前层输出 = [];

        for (let j = 0; j < 下一层神经元数量; j++) {
            let 当前神经元权重 = 当前层权重[j];
            let 当前神经元偏置 = 当前层偏置[j];

            let 加权和 = 当前神经元偏置;
            for (let k = 0; k < 当前层神经元数量; k++) {
                加权和 += 当前神经元权重[k] * 正向传播结果[k];
            }

            let 当前神经元激活 = relu(加权和);
            当前层输出.push(当前神经元激活);
        }
        正向传播结果 = 当前层输出;
    }
    打印(`前向传播完成:${正向传播结果}`);
    return 正向传播结果;
}
function relu(x) {
    if (x > 0) {
        return x;
    } else {
        return 0.01 * x;
    }
}
function 打印(内容) {
    console.log(require('util').inspect(内容, { depth: null }));
}
function 计算数组内数字总和(数组) {
    let 总和 = 0;
    for (let i = 0; i < 数组.length; i++) {
        总和 += 数组[i];
    }
    return 总和;
}
function 合并数组(数组1, 数组2) {
    let 合并后的数组 = 数组1.concat(数组2);
    return 合并后的数组;
}
function 元素在数组中的数量(元素, 数组) {
    let 数量 = 0;
    for (let i = 0; i < 数组.length; i++) {
        if (数组[i] == 元素) {
            数量++;
        }
    }
    return 数量;
}
function 分解文本为数组(文本) {
    let 数组 = 文本.split('');
    打印(`文本分解完成:${数组}`);
    return 数组;
}



function 生成预测模块() {

    const 预测模块参数 = 生成参数(预测模块构造);
    写入文件("预测模块.json", 预测模块参数)
    打印("初始预测模块生成完成:" + 预测模块参数);

}
function 读取预测模块() {
    const 预测模块参数 = 读取JSON文件("预测模块.json");
    打印("初始预测模块读取完成:" + 预测模块参数);
    return 预测模块参数;
}
function 生成记忆模块() {
    const 预测模块参数数量 = 合并数组(预测模块参数[0], 预测模块参数[1]).length;
    const 记忆模块输入数量 = 预测模块参数数量 + 2;
    const 记忆模块构造 = [记忆模块输入数量, 10, 预测模块参数数量];
    const 记忆模块参数 = 生成参数(记忆模块构造);
    打印("测试记忆模块生成完成："+记忆模块构造);
    return 记忆模块参数;
}
function 模型运行(输入, 输出) {
    const 预测模块输出 = 前向传播(输入, 预测模块参数);
    const 记忆模块输出 = 前向传播(合并数组([输入, 输出], 预测模块输出), 记忆模块参数);
    预测模块参数 = 记忆模块输出;
    return 预测模块输出;
}
function 模型学习() {
    for (let 输入 = 0; 输入 < 测试语料数组.length; 输入++) {
        模型运行(测试语料数组[输入], 测试语料数组[输入 + 1]);
    }
    打印("模型学习完成");
}
function 模型检验() {
    let 模型分数 = 100;
    for (let 输入 = 0; 输入 < 测试语料数组.length; 输入++) {
        const 期望输出 = 测试语料数组[输入 + 1]
        const 预测模块输出 = 模型运行(测试语料数组[输入], 期望输出);
        const 扣分 = 计算差值(预测模块输出, 期望输出);
        模型分数 = 模型分数 - 扣分;
    }
    打印("模型分数：" + 模型分数);
    if (模型分数 > 最高分) {
        最高分 = 模型分数;
        打印("新的最高分出现");
        写入文件("预测模块.json", 预测模块参数);
    }
}

/*
这个AI模型主要分为两个模块：预测模块、测试记忆模块。
首先，定义预测模块的构造。通过构造函数生成相应的参数，并将这些参数存储到名为"预测模块.json"的文件中。
接下来，生成记忆模块。生成记忆模块需要考虑预测模块参数的数量、预测模块的输入规模、预测模块的输出规模以及期望输出。根据这些信息，定义测试记忆模块的构造，并根据构造生成了相应的参数。
然后，进行模型的学习与检验。模型学习过程中，会对语料数组中的每个输入进行迭代。模型运行时会传入语料数组中的当前输入字和下一个输入字。模型会根据这两个输入进行处理和分析：{
    首先，将当前输入字作为预测模块的输入，输出预测出的字。
    接下来，将预测模块的输入、输出、期望输出和预测模块的所有参数作为记忆模块的输入，输出新的预测模块参数。
    最后将新的预测模块参数赋予给预测模块，以进行下一次迭代。
}
模型检验过程中，会对每个输入进行迭代。在每次迭代过程中，获取期望输出和预测模块的输出，并计算二者之差的绝对值，作为扣分的依据。
最终，根据扣分情况来判断模型的分数，并与之前的最高分进行比较。
在模型学习和模型检验完成之后，会输出模型的分数，并判断是否出现了新的最高分。如果出现了新的最高分，则会将当前记忆模块的参数写入到记忆模块.json文件中。
*/
